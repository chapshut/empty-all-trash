// background.jsasync function emptyAllTrash() {  try {    const accounts = await browser.accounts.list();    let totalDeleted = 0;    let errors = [];    for (const account of accounts) {      try {        // Find trash folder for this account        const trashFolder = await findTrashFolder(account);                if (trashFolder) {          // Get all messages in trash          const messages = await browser.messages.list(trashFolder);                    if (messages.messages && messages.messages.length > 0) {            // Delete all messages permanently            const messageIds = messages.messages.map(msg => msg.id);            await browser.messages.delete(messageIds, true); // true = skip trash            totalDeleted += messageIds.length;          }        }      } catch (err) {        errors.push(`${account.name}: ${err.message}`);      }    }    return { success: true, totalDeleted, errors };  } catch (error) {    return { success: false, error: error.message };  }}async function findTrashFolder(account) {  // Check root folders  for (const folder of account.folders) {    if (folder.type === "trash") {      return folder;    }    // Check subfolders recursively    const trashInSubfolder = await findTrashInSubfolders(folder);    if (trashInSubfolder) {      return trashInSubfolder;    }  }  return null;}async function findTrashInSubfolders(folder) {  if (folder.subFolders) {    for (const subfolder of folder.subFolders) {      if (subfolder.type === "trash") {        return subfolder;      }      const trashInDeeper = await findTrashInSubfolders(subfolder);      if (trashInDeeper) {        return trashInDeeper;      }    }  }  return null;}// Listen for messages from popupbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {  if (message.action === "emptyAllTrash") {    emptyAllTrash().then(sendResponse);    return true; // Keep message channel open for async response  }});